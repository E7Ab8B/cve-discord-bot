from __future__ import annotations

import logging

import jishaku

import aiohttp
import discord
from discord.ext import commands
from tortoise import Tortoise

from config import BOT_TOKEN, TORTOISE_ORM

EXTENSIONS_DIR = "extensions"

INITIAL_EXTENSIONS = (
    "cve_commands",
    "notification_tasks",
    "notification_commands",
)

logger = logging.getLogger(__name__)

jishaku.Flags.HIDE = True
jishaku.Flags.NO_DM_TRACEBACK = True
jishaku.Flags.NO_UNDERSCORE = True


class CveBot(commands.Bot):
    session: aiohttp.ClientSession

    def __init__(self) -> None:
        intents = discord.Intents(
            guilds=True,
            members=True,
            emojis=True,
            message_content=True,
            messages=True,
            reactions=True,
        )
        command_prefix = commands.when_mentioned_or("c-")

        super().__init__(command_prefix=command_prefix, intents=intents)

    def run(self, *args, **kwargs) -> None:
        super().run(BOT_TOKEN, log_handler=None, *args, **kwargs)

    async def on_ready(self) -> None:
        """
        Called when the bot is done preparing the data received from Discord.
        """
        if not hasattr(self, "uptime"):
            self.uptime = discord.utils.utcnow()

        assert self.user

        logger.info("Ready: %s (ID: %s)", self.user, self.user.id)

    async def on_connect(self) -> None:
        """Called when the bot connects to Discord.

        Connects to the database.
        """
        logger.info("Connected to Discord.")
        logger.info("Connecting to database...")

        await Tortoise.init(config=TORTOISE_ORM)
        await Tortoise.generate_schemas()

        logger.info("Connected to database.")

    async def on_disconnect(self) -> None:
        """Called when the bot disconnects from Discord.

        Disconnects from the database to make sure no data is lost.
        """
        logger.info("Disconnected from Discord.")
        logger.info("Disconnecting from database...")

        await Tortoise.close_connections()

        logger.info("Disconnected from database.")

    async def close(self) -> None:
        """Closes the bot and db connections."""
        await super().close()

        await self.session.close()
        await Tortoise.close_connections()

    async def load_extensions(self) -> None:
        """
        Loads extensions from :const:`INITIAL_EXTENSIONS` and loads jishaku.
        """
        for extension in INITIAL_EXTENSIONS:
            try:
                await self.load_extension(f"{EXTENSIONS_DIR}.{extension}")
                logger.info("Loaded %s", extension)
            except Exception:
                logger.exception("Failed to load extension %s.", extension)

        await self.load_jishaku()

        logger.info("Successfully loaded extensions")

    async def load_jishaku(self) -> None:
        """Loads jishaku extension."""
        await self.load_extension("jishaku")
        logger.info("Loaded jishaku")

    async def setup_hook(self) -> None:
        """A coroutine to be called to setup the bot.

        This is only called once, in :meth:`login`, and will be called before
        any events are dispatched.
        """
        self.session = aiohttp.ClientSession()

        await self.load_extensions()

        await self.tree.sync()

        logger.info("Successfully synced commands")
