from __future__ import annotations

import logging

import discord
from discord import app_commands as ac
from tortoise.exceptions import DoesNotExist
from tortoise.transactions import in_transaction

from .autocomplete import label_autocomplete
from models import Label, NotificationChannel
from utils.cog import BaseCog

MIN_LABELS_FOR_CHANNEL = 1
MAX_LABELS_FOR_CHANNEL = 10

logger = logging.getLogger(__name__)


class AdminCommands(BaseCog):
    """Cog that implements admin commands for setting up notification channels.

    Commands:
        `channel_add`
            Adds a channel to send notifications about newly added CVEs with
            provided labels.

        `attach_label`
            Attaches a label to notification channel.

        `detach_label`
            Detaches a label from notification channel.
    """

    @ac.command(name="channel-add")
    @ac.guild_only()
    @ac.default_permissions(administrator=True)
    @ac.autocomplete(label=label_autocomplete)
    @ac.describe(
        channel_name="Text channel to send notifications about newly added CVEs.",
        label="Existing label to find in the CVE descriptions.",
        topic="Channel's topic.",
    )
    async def channel_add(
        self,
        interaction: discord.Interaction,
        *,
        channel_name: ac.Range[str, 1, 20],
        label: str,
        topic: ac.Range[str, 1, 100] | None,
    ) -> None:
        """
        Adds a channel to send notifications about newly added CVEs with
        provided labels.

        Actions:
            1. Retrieves label from DB.
            2. Creates TextChannel (discord).
            3. Creates NotificationChannel (DB).
            4. Attaches label to channel.
            5. Sends success message.
        """
        assert interaction.guild

        try:
            label_db = await Label.get(name__iexact=label)
        except DoesNotExist:
            return await interaction.response.send_message(f"Label `{label}` was not found.")

        overwrites = {interaction.guild.default_role: discord.PermissionOverwrite(send_messages=False)}

        channel_kwargs = {
            "name": channel_name,
            "overwrites": overwrites,
        }

        if topic is not None:
            channel_kwargs["topic"] = topic

        try:
            channel = await interaction.guild.create_text_channel(**channel_kwargs)
        except discord.HTTPException as e:
            return await interaction.response.send_message(f"Failed to create channel. {e.text}")

        logger.debug("Channel with id: %s created", channel.id)

        async with in_transaction():
            channel_db = await NotificationChannel.create(
                channel_id=channel.id,
                guild_id=interaction.guild.id,
            )
            await channel_db.labels.add(label_db)

        logger.debug(
            "Created a notification channel. channel_id: %s guild_id: %s label__name: %s",
            channel.id,
            interaction.guild.id,
            label,
        )

        await interaction.response.send_message(
            content=f"{channel.mention} was successfully set for receiving CVE notifications.",
        )

    @ac.command(name="label-attach")
    @ac.guild_only()
    @ac.default_permissions(administrator=True)
    @ac.autocomplete(label=label_autocomplete)
    async def attach_label(
        self,
        interaction: discord.Interaction,
        *,
        channel: discord.TextChannel,
        label: str,
    ) -> None:
        """Attaches a label to notification channel."""
        try:
            channel_db = await NotificationChannel.get(channel_id=channel.id)
        except DoesNotExist:
            return await interaction.response.send_message(
                f"{channel.mention} is not set as a notification channel for CVEs."
            )

        if await channel_db.labels.filter(name__iexact="All").exists():
            return await interaction.response.send_message(
                "Channel has label `All` attached already. Attaching more labels would make no sense."
            )

        try:
            label_db = await Label.get(name__iexact=label)
        except DoesNotExist:
            return await interaction.response.send_message(f"Label `{label}` does not exist.")

        if await channel_db.labels.all().count() >= MAX_LABELS_FOR_CHANNEL:
            return await interaction.response.send_message(
                f"Max `{MAX_LABELS_FOR_CHANNEL}` labels are allowed to be attached to a notification channel."
                "Maybe label `All` that notifies about all CVEs would interest you?"
            )

        await channel_db.labels.add(label_db)

        await interaction.response.send_message(f"Successfully attached label `{label}` to {channel.mention}.")

    @ac.command(name="label-detach")
    @ac.guild_only()
    @ac.default_permissions(administrator=True)
    @ac.autocomplete(label=label_autocomplete)
    async def detach_label(
        self,
        interaction: discord.Interaction,
        *,
        channel: discord.TextChannel,
        label: str,
    ) -> None:
        """Detaches a label from notification channel.

        Removing a label when channel has lte :const:`MIN_LABELS_FOR_CHANNEL`
        is not allowed.
        """
        try:
            channel_db = await NotificationChannel.get(channel_id=channel.id)
        except DoesNotExist:
            return await interaction.response.send_message(
                f"{channel.mention} is not set as a notification channel for CVEs."
            )

        try:
            label_db = (await channel_db.labels.filter(name__iexact=label))[0]
        except IndexError:
            return await interaction.response.send_message(
                f"Label `{label}` does not exist or is not attached to {channel.mention}."
            )

        if await channel_db.labels.all().count() <= MIN_LABELS_FOR_CHANNEL:
            return await interaction.response.send_message(
                f"Notification channel must at least have `{MIN_LABELS_FOR_CHANNEL}` label attached to it."
            )

        await channel_db.labels.remove(label_db)

        await interaction.response.send_message(f"Successfully detached label `{label}` from {channel.mention}.")
