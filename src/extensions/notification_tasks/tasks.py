from __future__ import annotations

import asyncio
import datetime as dt
import logging
from typing import TYPE_CHECKING

import discord
from discord.ext import commands, tasks
from pydantic import ValidationError
from tortoise import timezone
from tortoise.exceptions import DoesNotExist, IntegrityError

from models import Cve, Label, NotificationChannel
from utils.cog import BaseCog
from utils.cve import (
    CveNotFoundError,
    add_latest_cve,
    create_cve,
    first_from_cves_response,
    request_cves,
    set_cves_notified,
)
from utils.embeds import CveEmbed
from utils.serializers import CveEmbedSerializer

if TYPE_CHECKING:
    from utils.types import CveResponse, CvesResponse, PubDateParameters

# NIST allows max 120 consecutive days difference between filtered dates
NIST_MAX_DATE_RANGE = 120

logger = logging.getLogger(__name__)


class UpdateCves(BaseCog):
    """Cog that implements task for retrieving new CVEs from NIST API.

    Tasks:
        `update_cves`
            Retrieves the latest CVEs that were released and then saves them.
    """

    async def cog_load(self) -> None:
        self.update_cves.start()

    async def cog_unload(self) -> None:
        self.update_cves.cancel()

    @tasks.loop(seconds=30.0)
    async def update_cves(self) -> None:
        """Retrieves the latest CVEs that were released and then saves them."""
        logger.debug("Task <update_cves> was called.")

        latest_saved = await Cve.first().only("published")
        params: dict[str, int | str] = {"resultsPerPage": 100}

        if latest_saved is None:
            try:
                latest_saved = await add_latest_cve(self.bot.session)
            except CveNotFoundError:
                return logger.error("Task <update_cves> ended. No `Cve` exist in DB and failed to add latest CVE.")

        # Filter CVE by the latest published date that was saved in DB
        params |= self.get_date_params(latest_saved)  # type: ignore

        if (data := await request_cves(self.bot.session, params=params)) is None:
            return logger.debug("Task <update_cves> ended. Got no data from NIST API.")

        # No vulnerabilities were returned, ends the task
        if not (vulnerabilities := data.get("vulnerabilities")):
            return logger.debug("Task <update_cves> ended. New CVEs were not found.")

        for vulnerability in vulnerabilities:
            try:
                cve = await create_cve(vulnerability["cve"])

            except ValidationError:
                logging.exception("Validation failed for %s.", vulnerability["cve"]["id"])

            except IntegrityError:
                logger.exception("Found duplicate for %s.", vulnerability["cve"]["id"])

            else:
                logger.debug("%s was added in the DB.", cve.cve_id)

        logger.debug("Task <update_cves> ended")

    def get_date_params(self, cve: Cve) -> PubDateParameters:
        """Returns date parameters that are used to filter CVEs."""
        now = timezone.now()
        if (now - cve.published).days <= NIST_MAX_DATE_RANGE:
            # Adding 1 microsecond cause the filter is GTE
            start_date = cve.published + dt.timedelta(milliseconds=1.0)
        else:
            start_date = now - dt.timedelta(days=NIST_MAX_DATE_RANGE)

        return {
            # HACK: NIST API is not working sometimes with timezones that are
            # not UTC. Changing here tzinfo to UTC.
            "pubStartDate": start_date.replace(tzinfo=dt.timezone.utc).isoformat(),
            "pubEndDate": timezone.now().replace(tzinfo=dt.timezone.utc).isoformat(),
        }

    @update_cves.before_loop
    async def before_tasks(self) -> None:
        """Coroutine that is called before `update_cves` starts running."""
        logger.debug("<update_cves> Waiting until bot is ready.")
        await self.bot.wait_until_ready()
        logger.debug("<update_cves> Done waiting for the bot to be ready.")


class Notifications(BaseCog):
    """Cog that implements tasks and listeners for notifications.

    Tasks:
        `notify_cve_channels`
            Sends notifications to channels for newly created CVEs.

    Listeners:
        `remove_cve_channel`
            Removes notification channels from DB which were removed fro
            guild.
    """

    async def cog_load(self) -> None:
        self.notify_cve_channels.start()

    async def cog_unload(self) -> None:
        self.notify_cve_channels.cancel()

    @tasks.loop(minutes=1)
    async def notify_cve_channels(self) -> None:
        """Sends notifications to channels for newly created CVEs.

        Actions:
        1. Retrieves CVEs that have `notified` set to `True`, with channel
        and labels from DB.
        2. Gets data from NIST for all CVEs.
        3. Serialize and create embeds.
        4. Send CVE embeds to the channels.
        5. Set `notified` to `True` for all CVEs.
        """
        logger.debug("Task <notify_cve_channels> was called.")

        # Queries
        query_tasks = [
            NotificationChannel.all().only("channel_id", "id").prefetch_related("labels"),
            Cve.filter(notified=False).only("cve_id", "id").order_by("published"),
            Label.all().only("name", "keywords").order_by("name"),
        ]
        channels, cves, labels = await asyncio.gather(*query_tasks)

        if not cves:
            logger.debug("Task <notify_cve_channels> ended. Nothing to notify about.")
            return

        get_cve_tasks = [self.get_cve_from_nist(cve.cve_id) for cve in cves]
        # Removes failed (None) requests from the list
        cve_responses = list(filter(lambda response: response is not None, await asyncio.gather(*get_cve_tasks)))

        logger.debug("<notify_cve_channels> Got %s CVE responses", len(cve_responses))

        # If no channels were found, just exit and set CVEs as notified
        if not channels:
            await set_cves_notified(cves)

            return logger.debug("Task <notify_cve_channels> ended. No channel exists.")

        embeds_by_labels = self.get_cve_embeds(labels, cve_responses)

        logger.debug("Got %s embeds to send", sum(len(embeds) for embeds in embeds_by_labels.values()))

        for channel in channels:
            embeds_to_send: list[CveEmbed] = []

            for label in await channel.labels.all():
                for embed in embeds_by_labels[label.name]:
                    # Duplicates are possible (multiple labels might be found for the same CVE)
                    if embed not in embeds_to_send:
                        embeds_to_send.append(embed)

            await self.send_cve_notifications(channel.channel_id, embeds_to_send)

        await set_cves_notified(cves)

        logger.debug("Task <notify_cve_channels> ended")

    @commands.Cog.listener("on_guild_channel_delete")
    async def remove_cve_channel(self, channel: discord.abc.GuildChannel) -> None:
        """Removes notification channels from DB which were removed from guild."""
        if not isinstance(channel, discord.TextChannel):
            return

        try:
            channel_db = await NotificationChannel.get(channel_id=channel.id).only("id", "channel_id")
        except DoesNotExist:
            return

        logger.error("Deleted NotificationChannel <channel_id=%s> which was removed from the guild.", channel.id)
        await channel_db.delete()

    @notify_cve_channels.before_loop
    async def before_notify_cve_channels(self) -> None:
        """Coroutine that is called before `notify_cve_channels` starts running."""
        logger.debug("<notify_cve_channels> Waiting until bot is ready.")
        await self.bot.wait_until_ready()
        logger.debug("<notify_cve_channels> Done waiting for the bot to be ready.")

    async def get_cve_from_nist(self, cve_id: str) -> CveResponse | None:
        """Retrieves CVE from NIST API and returns a :obj:`dict` or :obj:`None`."""
        data = await request_cves(self.bot.session, params={"cveId": cve_id})
        if data is None:
            return None

        try:
            return first_from_cves_response(data)
        except CveNotFoundError:
            return None

    def get_cve_embeds(
        self,
        labels: list[Label],
        cve_responses: list[CvesResponse],
    ) -> dict[str, list[CveEmbed]]:
        """
        Returns a :obj:`dict` with keys as label names values as :obj:`list`
        of CVE embeds.

        CVE embeds may be duplicated in different values.  CVE can have
        multiple labels.
        """
        embeds_by_labels: dict[str, list[CveEmbed]] = {label.name: [] for label in labels}

        for cve_response in cve_responses:
            try:
                serializer = CveEmbedSerializer.parse_obj(cve_response)
            except ValidationError:
                logging.exception("Validation failed for %s", cve_response.get("id", "'id' NOT FOUND"))
                break

            for label in labels:
                # NOTE: Label for labelling ALL CVEs
                if label.name == "All":
                    found_keywords = serializer.add_label(label.name)
                else:
                    found_keywords = serializer.add_label(label.name, label.keywords)

                if found_keywords:
                    logger.debug(
                        "Found keywords: %s for label %s in %s",
                        found_keywords,
                        label.name,
                        serializer.cve_id,
                    )

                embed = CveEmbed.from_serializer(serializer)

                for label_name in serializer.labels:
                    embeds_by_labels[label_name].append(embed)

        return embeds_by_labels

    async def send_cve_notifications(self, channel_id: int, embeds: list[CveEmbed]) -> None:
        """
        Sends multiple CVE embeds to :class:`~discord.TextChannel` that has
        the ID equal to :param:`channel_id`.
        """
        tasks = [self.send_cve_notification(channel_id, embed) for embed in embeds]
        await asyncio.gather(*tasks)

    async def send_cve_notification(self, channel_id: int, embed: CveEmbed) -> None:
        """
        Sends a CVE embed to :class:`~TextChannel` that has the ID equal to
        :param:`channel_id`.
        """
        channel_dc = self.bot.get_channel(channel_id)
        if not isinstance(channel_dc, discord.TextChannel):
            return logger.warning(
                "Failed to send CVE notification to channel with ID %s for embed title %s. "
                "Channel does not exist or is a wrong type",
                channel_id,
                embed.title,
            )

        try:
            await channel_dc.send(embed=embed)
        except discord.HTTPException:
            debug_message = "Failed to send CVE notification to channel with ID %s for embed title %s"
        else:
            debug_message = "Sent CVE notification to channel with ID %s for %s"

        logger.debug(debug_message, channel_id, embed.title)
